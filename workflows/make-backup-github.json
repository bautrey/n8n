{
  "name": "Make.com → GitHub Backup",
  "nodes": [
    {
      "parameters": {
        "interval": 1,
        "unit": "hours"
      },
      "name": "Daily 2AM CST Trigger",
      "type": "n8n-nodes-base.interval",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "executionId",
              "value": "={{ $execution.id }}"
            },
            {
              "name": "workflowId",
              "value": "={{ $workflow.id }}"
            },
            {
              "name": "executionStartTime",
              "value": "={{ $now.toISO() }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Initialize Execution Context",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/bautrey/make-scenarios-backup/contents/backup-state.json",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=token {{ $env.GITHUB_PAT }}"
            }
          ]
        },
        "options": {
          "allowUnauthorizedCerts": false,
          "followRedirect": true
        }
      },
      "name": "Read Backup State",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Parse the backup state from GitHub response\n// GitHub file is the source of truth for scenario timestamps\n\nconst items = $input.all();\n\nif (items.length === 0 || items[0].json.error) {\n  // File doesn't exist or error occurred, return empty state\n  return [\n    {\n      json: {\n        lastBackup: {},\n        metadata: {\n          firstBackup: $now.toISO(),\n          totalBackups: 0\n        },\n        _githubSha: null\n      }\n    }\n  ];\n}\n\n// Decode base64 content from GitHub\nconst content = items[0].json.content;\nconst decodedContent = Buffer.from(content, 'base64').toString('utf-8');\nconst backupState = JSON.parse(decodedContent);\n\n// Store the SHA for later update\nconst sha = items[0].json.sha;\n\nreturn [\n  {\n    json: {\n      lastBackup: backupState.lastBackup || {},\n      metadata: backupState.metadata || { firstBackup: $now.toISO(), totalBackups: 0 },\n      _githubSha: sha\n    }\n  }\n];"
      },
      "name": "Parse Backup State",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "url": "https://us1.make.com/api/v2/scenarios?teamId=154819",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Token {{ $env.MAKE_API_KEY }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Fetch All Scenarios",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "// Filter scenarios that have changed since last backup\n\nconst scenarios = $input.all()[0].json.scenarios || [];\nconst backupState = $node['Parse Backup State'].json;\nconst lastBackup = backupState.lastBackup || {};\n\n// Debug scenario 583650\nconst testScenario = scenarios.find(s => s.id === 583650);\nif (testScenario) {\n  const lastEditMs = new Date(testScenario.lastEdit).getTime();\n  const lastBackupMs = lastBackup['583650'] ? new Date(lastBackup['583650']).getTime() : 0;\n  console.log(`DEBUG 583650: lastEdit=${testScenario.lastEdit} (${lastEditMs}), stored=${lastBackup['583650']} (${lastBackupMs}), changed=${lastEditMs > lastBackupMs}`);\n}\n\nconst changedScenarios = scenarios.filter(scenario => {\n  const scenarioId = scenario.id.toString();\n  const lastEditedDate = new Date(scenario.lastEdit).getTime();\n  const lastBackupDate = lastBackup[scenarioId] \n    ? new Date(lastBackup[scenarioId]).getTime() \n    : 0;\n  \n  return lastEditedDate > lastBackupDate;\n});\n\nconsole.log(`Total scenarios: ${scenarios.length}`);\nconsole.log(`Changed scenarios: ${changedScenarios.length}`);\n\nreturn changedScenarios.map(scenario => ({ json: scenario }));"
      },
      "name": "Filter Changed Scenarios",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "name": "Split Scenarios",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "url": "=https://us1.make.com/api/v2/scenarios/{{$json.id}}/blueprint",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Token {{ $env.MAKE_API_KEY }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Download Blueprint",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/bautrey/make-scenarios-backup/contents/scenarios/{{$node['Split Scenarios'].json.id}}.json",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=token {{ $env.GITHUB_PAT }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Check Existing File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1850, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Prepare commit data for GitHub\n// Base64 encode blueprint and format commit message\n\nconst scenarioData = $node['Split Scenarios'].json;\nconst blueprint = $input.all()[0].json.response || $input.all()[0].json;\nconst existingFile = $node['Check Existing File'].json;\n\n// Base64 encode the blueprint\nconst blueprintJson = JSON.stringify(blueprint, null, 2);\nconst base64Content = Buffer.from(blueprintJson).toString('base64');\n\n// Format commit message\nconst scenarioId = scenarioData.id;\nconst scenarioName = scenarioData.name || `Scenario ${scenarioId}`;\nconst commitMessage = `Update scenario ${scenarioId}: ${scenarioName}`;\n\n// Extract SHA if file exists (required for updates)\nconst sha = existingFile.sha || null;\n\nreturn [\n  {\n    json: {\n      scenarioId,\n      scenarioName,\n      commitMessage,\n      base64Content,\n      sha,\n      lastEditedDate: scenarioData.lastEdit\n    }\n  }\n];"
      },
      "name": "Prepare Commit Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "url": "=https://api.github.com/repos/bautrey/make-scenarios-backup/contents/scenarios/{{$json.scenarioId}}.json",
        "method": "PUT",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=token {{ $env.GITHUB_PAT }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "message",
              "value": "={{ $json.commitMessage }}"
            },
            {
              "name": "content",
              "value": "={{ $json.base64Content }}"
            },
            {
              "name": "sha",
              "value": "={{ $json.sha }}"
            },
            {
              "name": "branch",
              "value": "main"
            }
          ]
        },
        "options": {}
      },
      "name": "Commit Scenario File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "functionCode": "// Update workflowStaticData IMMEDIATELY after each scenario commit\n// This ensures progress is saved even if workflow fails partway through\n\nconst scenarioData = $node['Split Scenarios'].json;\nconst scenarioId = scenarioData.id.toString();\nconst scenarioLastEdit = scenarioData.lastEdit;\n\n// Get static data reference (persists between executions)\nconst staticData = getWorkflowStaticData('global');\n\n// Update this scenario's timestamp in static data\nstaticData.lastBackup[scenarioId] = scenarioLastEdit;\nstaticData.metadata.lastBackupTime = $now.toISO();\n\n// Pass through for loop continuation\nreturn $input.all();"
      },
      "name": "Update Static Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2450, 300]
    },
    {
      "parameters": {
        "functionCode": "// Export final backup state to GitHub as backup/audit trail\n// Build updated lastBackup from original state + newly processed scenarios\n\nconst parseBackupState = $node['Parse Backup State'].json;\nconst lastBackup = parseBackupState.lastBackup || {};\nconst allScenarios = $node['Fetch All Scenarios'].json.scenarios || [];\n\n// Get all changed scenarios from the Fetch All Scenarios response\n// and filter them based on timestamps (same logic as Filter node)\nconst changedScenarios = allScenarios.filter(scenario => {\n  const scenarioId = scenario.id.toString();\n  const lastEditedDate = new Date(scenario.lastEdit).getTime();\n  const lastBackupDate = lastBackup[scenarioId] \n    ? new Date(lastBackup[scenarioId]).getTime() \n    : 0;\n  \n  return lastEditedDate > lastBackupDate;\n});\n\n// Update lastBackup timestamps for all changed scenarios\nchangedScenarios.forEach(scenario => {\n  lastBackup[scenario.id.toString()] = scenario.lastEdit;\n});\n\n// Prepare updated metadata\nconst metadata = {\n  firstBackup: parseBackupState.metadata?.firstBackup || $now.toISO(),\n  totalBackups: (parseBackupState.metadata?.totalBackups || 0) + 1,\n  lastBackupTime: $now.toISO(),\n  totalScenarios: allScenarios.length,\n  backedUpScenarios: Object.keys(lastBackup).length\n};\n\nconst backupState = {\n  lastBackup: lastBackup,\n  metadata: metadata\n};\n\nreturn [\n  {\n    json: {\n      backupState: backupState\n    }\n  }\n];"
      },
      "name": "Export Backup State to GitHub",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2650, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/bautrey/make-scenarios-backup/contents/backup-state.json",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=token {{ $env.GITHUB_PAT }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Get Current Backup State SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2750, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Prepare GitHub commit payload with backup state and SHA\nconst backupStateNode = $node['Export Backup State to GitHub'].json;\nconst githubResponse = $input.all()[0].json;\n\n// Base64 encode the backup state for GitHub\nconst backupStateJson = JSON.stringify(backupStateNode.backupState, null, 2);\nconst base64Content = Buffer.from(backupStateJson).toString('base64');\n\nreturn [\n  {\n    json: {\n      content: base64Content,\n      sha: githubResponse.sha || null,\n      message: `Update backup state - ${new Date().toISOString()}`\n    }\n  }\n];"
      },
      "name": "Prepare Commit Payload",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2850, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/bautrey/make-scenarios-backup/contents/backup-state.json",
        "method": "PUT",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=token {{ $env.GITHUB_PAT }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "message",
              "value": "={{ $json.message }}"
            },
            {
              "name": "content",
              "value": "={{ $json.content }}"
            },
            {
              "name": "sha",
              "value": "={{ $json.sha }}"
            },
            {
              "name": "branch",
              "value": "main"
            }
          ]
        },
        "options": {}
      },
      "name": "Commit Backup State",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "functionCode": "// Aggregate results from workflow execution\n// Count total scenarios, successful commits, errors\n\nconst executionContext = $node['Initialize Execution Context'].json;\nconst allScenarios = $node['Fetch All Scenarios'].json.scenarios || [];\nconst changedScenariosCount = $node['Filter Changed Scenarios'].json?.length || 0;\n\n// Calculate execution duration\nconst startTime = new Date(executionContext.executionStartTime);\nconst endTime = new Date();\nconst durationMs = endTime - startTime;\nconst durationSec = Math.round(durationMs / 1000);\nconst durationMin = Math.floor(durationSec / 60);\nconst durationRemainingSec = durationSec % 60;\nconst durationFormatted = `${durationMin}m ${durationRemainingSec}s`;\n\n// TODO: Count actual successes and errors from loop\n// For now, assume all changed scenarios were successful\nconst successCount = changedScenariosCount;\nconst errorCount = 0;\nconst skippedCount = allScenarios.length - changedScenariosCount;\n\nreturn [\n  {\n    json: {\n      totalScenarios: allScenarios.length,\n      changedScenarios: changedScenariosCount,\n      successfulCommits: successCount,\n      errors: errorCount,\n      skipped: skippedCount,\n      duration: durationFormatted,\n      durationSeconds: durationSec,\n      executionId: executionContext.executionId,\n      timestamp: endTime.toISOString()\n    }\n  }\n];"
      },
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "functionCode": "// Format Slack message per PRD specification\n\nconst stats = $input.all()[0].json;\nconst emoji = stats.errors > 0 ? '⚠️' : '✅';\nconst status = stats.errors > 0 ? 'COMPLETED WITH ERRORS' : 'SUCCESS';\n\n// Format message following PRD specification\nconst message = `${emoji} *Make.com → GitHub Backup: ${status}*\n\n*Workflow:* Make.com Scenario Backup\n*Context:* Automated daily backup (2:00 AM CST)\n*Timestamp:* ${stats.timestamp}\n*Duration:* ${stats.duration}\n\n*Summary:*\n• Total scenarios in Make.com: ${stats.totalScenarios}\n• Changed scenarios: ${stats.changedScenarios}\n• Successfully backed up: ${stats.successfulCommits}\n• Skipped (no changes): ${stats.skipped}\n• Errors: ${stats.errors}\n\n*Details:*\n• Repository: bautrey/make-scenarios-backup\n• Branch: main\n• Execution ID: ${stats.executionId}\n\n*Changes:* ${stats.changedScenarios} scenario(s) updated in GitHub`;\n\nreturn [\n  {\n    json: {\n      message,\n      stats\n    }\n  }\n];"
      },
      "name": "Format Slack Message",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [3250, 300]
    },
    {
      "parameters": {
        "resource": "message",
        "channel": "={{ $env.SLACK_CHANNEL_ID }}",
        "text": "={{ $json.message }}",
        "otherOptions": {}
      },
      "name": "Send Slack Notification",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 1,
      "position": [3450, 300],
      "credentials": {
        "slackApi": {
          "id": "1",
          "name": "Slack n8n Bot"
        }
      }
    }
  ],
  "connections": {
    "Daily 2AM CST Trigger": {
      "main": [
        [
          {
            "node": "Initialize Execution Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Execution Context": {
      "main": [
        [
          {
            "node": "Read Backup State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Backup State": {
      "main": [
        [
          {
            "node": "Parse Backup State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Backup State": {
      "main": [
        [
          {
            "node": "Fetch All Scenarios",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch All Scenarios": {
      "main": [
        [
          {
            "node": "Filter Changed Scenarios",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Changed Scenarios": {
      "main": [
        [
          {
            "node": "Split Scenarios",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Scenarios": {
      "main": [
        [
          {
            "node": "Download Blueprint",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Export Backup State to GitHub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Blueprint": {
      "main": [
        [
          {
            "node": "Check Existing File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Existing File": {
      "main": [
        [
          {
            "node": "Prepare Commit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Commit Data": {
      "main": [
        [
          {
            "node": "Commit Scenario File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Commit Scenario File": {
      "main": [
        [
          {
            "node": "Split Scenarios",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Export Backup State to GitHub": {
      "main": [
        [
          {
            "node": "Get Current Backup State SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Current Backup State SHA": {
      "main": [
        [
          {
            "node": "Prepare Commit Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Commit Payload": {
      "main": [
        [
          {
            "node": "Commit Backup State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Commit Backup State": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Format Slack Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Slack Message": {
      "main": [
        [
          {
            "node": "Send Slack Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {}
}
